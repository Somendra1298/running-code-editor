<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Code Editor</title>
    <!-- Prism CSS for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Inter:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1e1e1e; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #e5e7eb;
        }

        /* Full Screen Editor Container */
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            transition: opacity 0.5s ease, transform 0.5s ease;
            display: flex;
            flex-direction: column;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* The Code Editor */
        .editor {
            flex-grow: 1;
            font-family: 'Fira Code', monospace;
            font-size: 16px;
            line-height: 1.6;
            color: #d4d4d4;
            outline: none;
            border: none;
            padding: 2rem;
            resize: none;
            background: transparent;
            box-sizing: border-box;
            overflow: auto;
            tab-size: 2;
        }

        /* Floating Run Button */
        #run-btn {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            background-color: #6366f1; /* Indigo */
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
            transition: all 0.2s;
            z-index: 20;
        }

        #run-btn:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        #run-btn:active {
            transform: translateY(1px);
        }

        /* Canvas */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* Reset button */
        #reset-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            z-index: 30;
            display: none;
            font-weight: 600;
            backdrop-filter: blur(5px);
            transition: background 0.2s;
        }
        
        #reset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Bug Button */
        #bug-btn {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #ef4444; /* Red */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            z-index: 30;
            display: none;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(239, 68, 68, 0.3);
            transition: transform 0.1s;
        }

        #bug-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }
        
        #bug-btn:active {
            transform: scale(0.95);
        }

        /* Hands Toggle Button */
        #hands-btn {
            position: fixed;
            top: 1rem;
            right: 10rem; /* Positioned to the left of the bug button */
            background: #4b5563; /* Gray */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            z-index: 30;
            display: none;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(75, 85, 99, 0.3);
            transition: transform 0.1s;
        }

        #hands-btn:hover {
            background: #374151;
            transform: scale(1.05);
        }
        
        #hands-btn:active {
            transform: scale(0.95);
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-container">
        <!-- Default code snippet -->
        <div id="editor" class="editor">function hello() {
  const message = "Catch me if you can!";
  console.log(message);
  
  // Click RUN to see us move!
  return true;
}</div>
        <button id="run-btn">RUN CODE</button>
    </div>

    <button id="reset-btn">Back to Code</button>
    <button id="hands-btn">Hands: ON</button>
    <button id="bug-btn">Spawn Bug ðŸª°</button>

    <!-- Load PrismJS (Global) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

    <!-- Main Script as Module for CodeJar -->
    <script type="module">
        import { CodeJar } from 'https://cdn.jsdelivr.net/npm/codejar@3.7.0/codejar.js?module';

        // --- Editor Setup ---
        const editorElement = document.getElementById('editor');
        const highlight = (editor) => {
            // Prism highlight
            editor.innerHTML = Prism.highlight(editor.textContent, Prism.languages.javascript, 'javascript');
        }
        
        // Initialize CodeJar
        const jar = CodeJar(editorElement, highlight);
        // Initial highlight
        highlight(editorElement);


        // --- Game Logic ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiContainer = document.getElementById('ui-container');
        const runBtn = document.getElementById('run-btn');
        const resetBtn = document.getElementById('reset-btn');
        const bugBtn = document.getElementById('bug-btn');
        const handsBtn = document.getElementById('hands-btn');

        let width, height;
        let runners = [];
        let bugs = [];
        let animationId;
        let isRunning = false;
        
        // Flags
        let showHands = true;

        // Speed control
        const LIMB_SPEED = 0.005; // Slightly slower limbs to match running speed
        const MAX_RUNNER_SPEED = 2.5; // Cap the maximum running speed
        const BUG_WING_SPEED = 0.2; // Slower wing flap speed
        const BUG_MOVE_SPEED = 3.0; // Reduced flying speed (Base speed)
        
        // Spawn Animation Settings
        const INITIAL_SPAWN_RATE = 100; // Start slow (100ms gap)
        const MAX_SPAWN_RATE = 2;       // End fast (2ms gap)
        const SPAWN_ACCELERATION = 0.96; // How fast it speeds up (lower = faster acceleration)

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        class Bug {
            constructor() {
                // Spawn randomly off-screen or edges
                this.x = Math.random() < 0.5 ? -20 : width + 20;
                this.y = Math.random() * height;
                this.size = 10; // Increased size
                
                // Speed controlled by variable (Base speed + random variance)
                this.speed = BUG_MOVE_SPEED + Math.random() * (BUG_MOVE_SPEED * 0.5);
                
                this.angle = 0;
                this.wingAngle = 0;
                this.target = null;
            }

            findTarget(runners) {
                // Find nearest ACTIVE runner
                let minDist = Infinity;
                let closest = null;
                
                runners.forEach(runner => {
                    if (!runner.active) return; // Don't eat inactive letters
                    const dx = runner.x - this.x;
                    const dy = runner.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = runner;
                    }
                });
                return closest;
            }

            update(runners) {
                // Determine target
                if (!this.target || !runners.includes(this.target)) {
                    this.target = this.findTarget(runners);
                }

                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    this.angle = Math.atan2(dy, dx);
                    
                    // Move towards target
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;

                    // Eat if close
                    if (dist < 20) {
                        this.target.isEaten = true;
                        this.target = null;
                    }
                } else {
                    // Wander if no food
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    
                    if (Math.random() < 0.05) {
                        this.angle += (Math.random() - 0.5) * 2;
                    }

                    // Keep in bounds ish
                    if (this.x < -50) this.x = width + 50;
                    if (this.x > width + 50) this.x = -50;
                    if (this.y < -50) this.y = height + 50;
                    if (this.y > height + 50) this.y = -50;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2); // Face forward

                // Add a glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f59e0b'; // Amber glow

                // Wings
                this.wingAngle += BUG_WING_SPEED;
                const wingOffset = Math.sin(this.wingAngle) * 5;

                // Brighter, less transparent wings
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                
                // Left Wing (larger)
                ctx.beginPath();
                ctx.ellipse(-8 - wingOffset/2, 2, 12, 6, Math.PI/4, 0, Math.PI*2);
                ctx.fill();
                
                // Right Wing (larger)
                ctx.beginPath();
                ctx.ellipse(8 + wingOffset/2, 2, 12, 6, -Math.PI/4, 0, Math.PI*2);
                ctx.fill();

                // Body (bright color, larger)
                ctx.fillStyle = '#fbbf24'; // Bright amber/yellow body
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI*2); // Increased radius from 5 to 8
                ctx.fill();

                // Eyes (larger red eyes)
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(-3, -5, 2.5, 0, Math.PI*2); // Larger eyes
                ctx.arc(3, -5, 2.5, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Runner {
            constructor(char, x, y, delay, color) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.color = color || '#e5e7eb'; 
                
                // Random velocity - Much slower start
                const speed = 0.5 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.size = 18; 
                this.phase = Math.random() * 100;
                this.legLength = 10;
                this.armLength = 8;

                // For "waking up" effect: delayed movement
                this.active = false;
                this.wakeDelay = delay; 
                this.startTime = Date.now();
                this.isEaten = false; // New flag for death
            }

            update() {
                // Check if woke up
                if (!this.active) {
                    if (Date.now() - this.startTime > this.wakeDelay) {
                        this.active = true;
                    } else {
                        return; // Stand still
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < 10 || this.x > width - 10) {
                    this.vx *= -1;
                    this.x = Math.max(10, Math.min(width - 10, this.x));
                }
                
                if (this.y < 10 || this.y > height - 10) {
                    this.vy *= -1;
                    this.y = Math.max(10, Math.min(height - 10, this.y));
                }

                // Random chaotic movement
                if (Math.random() < 0.02) {
                    this.vx += (Math.random() - 0.5) * 0.5; // Reduced chaos bursts
                    this.vy += (Math.random() - 0.5) * 0.5;
                    
                    const maxSpeed = MAX_RUNNER_SPEED;
                    const speed = Math.sqrt(this.vx**2 + this.vy**2);
                    if (speed > maxSpeed) {
                        this.vx = (this.vx / speed) * maxSpeed;
                        this.vy = (this.vy / speed) * maxSpeed;
                    }
                }
            }

            draw(ctx, time) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw Text
                ctx.font = `bold ${this.size}px 'Fira Code', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = this.color; 
                ctx.fillText(this.char, 0, 0);

                // Draw Limbs
                let currentLimbSpeed = LIMB_SPEED;

                if (!this.active) {
                    currentLimbSpeed = 0; 
                }

                // Only draw limbs if active AND flag is set to true
                if (this.active && showHands) {
                    const runCycle = (time + this.phase) * currentLimbSpeed;
                    
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = this.color; 
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    const hipY = this.size / 2 - 2; 
                    const hipX = 0;

                    // Left Leg
                    const lLegAngle = Math.sin(runCycle) * 0.8;
                    this.drawLimb(ctx, hipX - 2, hipY, lLegAngle, this.legLength);

                    // Right Leg
                    const rLegAngle = Math.sin(runCycle + Math.PI) * 0.8;
                    this.drawLimb(ctx, hipX + 2, hipY, rLegAngle, this.legLength);

                    // Arms
                    const shoulderY = -2;
                    const shoulderX = 0;

                    // Left Arm
                    const lArmAngle = Math.sin(runCycle + Math.PI) * 0.8; 
                    this.drawLimb(ctx, shoulderX - 6, shoulderY, lArmAngle + 0.5, this.armLength);

                    // Right Arm
                    const rArmAngle = Math.sin(runCycle) * 0.8;
                    this.drawLimb(ctx, shoulderX + 6, shoulderY, rArmAngle - 0.5, this.armLength);
                }

                ctx.restore();
            }

            drawLimb(ctx, originX, originY, angle, length) {
                const kneeX = originX + Math.sin(angle) * (length * 0.6);
                const kneeY = originY + Math.cos(angle) * (length * 0.6);

                const footAngle = angle + (Math.sin(Date.now() * LIMB_SPEED) * 0.5); 
                
                const footX = kneeX + Math.sin(angle * 1.2) * (length * 0.6);
                const footY = kneeY + Math.cos(angle * 1.2) * (length * 0.6);

                ctx.beginPath();
                ctx.moveTo(originX, originY);
                ctx.lineTo(kneeX, kneeY);
                ctx.lineTo(footX, footY);
                ctx.stroke();
            }
        }

        function animate() {
            if (!isRunning) return;

            ctx.clearRect(0, 0, width, height);
            const time = Date.now();

            // Update & Draw Runners
            // Filter out eaten runners
            runners = runners.filter(r => !r.isEaten);

            runners.forEach(runner => {
                runner.update();
                runner.draw(ctx, time);
            });

            // Update & Draw Bugs
            bugs.forEach(bug => {
                bug.update(runners);
                bug.draw(ctx);
            });

            animationId = requestAnimationFrame(animate);
        }

        function startRunning() {
            // Check if empty
            if (!editorElement.textContent.trim()) return;

            // --- Layout Calculation ---
            ctx.font = "16px 'Fira Code', monospace";
            const charWidth = ctx.measureText('M').width;
            
            // Editor CSS values
            const fontSize = 16;
            const lineHeight = fontSize * 1.6; // 25.6px
            const padding = 32; // 2rem = 32px
            
            const scrollTop = editorElement.scrollTop;
            const scrollLeft = editorElement.scrollLeft;

            uiContainer.classList.add('hidden');
            resetBtn.style.display = 'block';
            bugBtn.style.display = 'block';
            handsBtn.style.display = 'block';
            
            runners = [];
            bugs = []; // Clear bugs on restart
            
            let col = 0;
            let row = 0;
            
            // Acceleration Logic State
            let currentSpawnInterval = INITIAL_SPAWN_RATE;
            let accumulatedDelay = 0;

            // Helper to process text segment with a specific color
            function processTextSegment(text, color) {
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];

                    if (char === '\n') {
                        col = 0;
                        row++;
                        continue;
                    }
                    if (char === '\t') {
                        col += 2;
                        continue;
                    }

                    if (!char.match(/\s/)) {
                        const x = padding + (col * charWidth) - scrollLeft + (charWidth / 2);
                        const y = padding + (row * lineHeight) - scrollTop + (lineHeight / 2);
                        
                        // Use accumulated delay for smooth acceleration
                        runners.push(new Runner(char, x, y, accumulatedDelay, color));
                        
                        // Update the delay for the NEXT character
                        accumulatedDelay += currentSpawnInterval;
                        
                        // Accelerate: reduce the interval until we hit the speed limit
                        currentSpawnInterval = Math.max(MAX_SPAWN_RATE, currentSpawnInterval * SPAWN_ACCELERATION);
                    }
                    col++;
                }
            }

            // Recursive function to walk DOM nodes and extract text + computed colors
            function walkNodes(node) {
                if (node.nodeType === 3) { // Text Node
                    // Get color from parent element (since text nodes don't have style)
                    const color = window.getComputedStyle(node.parentNode).color;
                    processTextSegment(node.nodeValue, color);
                } else if (node.nodeType === 1) { // Element Node
                    // Recurse children
                    node.childNodes.forEach(walkNodes);
                }
            }

            // Start walking the DOM from the editor root
            editorElement.childNodes.forEach(walkNodes);

            isRunning = true;
            animate();
        }

        function resetGame() {
            isRunning = false;
            cancelAnimationFrame(animationId);
            ctx.clearRect(0, 0, width, height);
            
            uiContainer.classList.remove('hidden');
            resetBtn.style.display = 'none';
            bugBtn.style.display = 'none';
            handsBtn.style.display = 'none';
            bugs = [];
        }

        function spawnBug() {
            bugs.push(new Bug());
        }

        function toggleHands() {
            showHands = !showHands;
            handsBtn.textContent = `Hands: ${showHands ? 'ON' : 'OFF'}`;
            handsBtn.style.background = showHands ? '#4b5563' : '#9ca3af'; // Dim if off
        }

        runBtn.addEventListener('click', startRunning);
        resetBtn.addEventListener('click', resetGame);
        bugBtn.addEventListener('click', spawnBug);
        handsBtn.addEventListener('click', toggleHands);

    </script>
</body>
</html>